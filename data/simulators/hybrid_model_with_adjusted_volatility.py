import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import sys
import os
import psycopg2

# Append project root directory to the system path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
sys.path.insert(0, project_root)

# Import configuration and strategies
from data.config_database import load_config

""""
The aim of this code is to generate hybrid prices with simulated OHLCV values from bitcoin's actual OHLCVs. 
The calculation of hybrid prices in the code uses the cumulative sum of logarithmic returns( Log_return{t} = log{Pt/Pt-1}),
which means that the price at any instant T is influenced by all previous logarithmic returns, not just the one at T-1. 
This allows us to capture the overall evolution of the price over time, and to simulate more realistic price trajectories.
The results are then exported in CSV format and visualized.
"""


# Parameter
token = 'BTC-USD'
start_date = '2022-12-11'
end_date = '2024-07-25'
interval = '15MIN'

# Download historical Bitcoin data with OHLCV data
#btc_data = yf.download(token, start=start_date, end=end_date, interval=interval)

config = load_config()
conn = psycopg2.connect(**config)
table_name = f"ohlcv_btc_usd_spot_{interval}"
query = f"SELECT * FROM {table_name};"
btc_data = pd.read_sql(query, conn)
btc_data = btc_data[['time_period_start', 'price_open', 'price_high', 'price_low', 'price_close', 'volume_traded']].rename(columns={'price_close': 'Close'})

# Calculate log yields for real prices
btc_data['Log_Return'] = np.log(btc_data['Close'] / btc_data['Close'].shift(1))

# Define the functions of volatility
def historical_volatility(log_returns, window=20):
    return log_returns.rolling(window=window).std()

def adjusted_volatility(log_returns, window=20):
    return historical_volatility(log_returns, window)

def moving_average_volatility(log_returns, window=50):
    return log_returns.rolling(window=window).std()

def exponential_volatility(log_returns, span=20):
    return log_returns.ewm(span=span).std()

def select_volatility_model(log_returns, model='historical'):
    """
    Selects and applies a volatility model to log returns.
    
    Parameters:
    - log_returns (Series): Log returns of a price series.
    - model (str): The volatility model to apply ('historical', 'adjusted', 'moving_average', 'exponential').
    
    Returns:
    - Series: Calculated volatility based on the selected model.
    """
    if model == 'historical':
        return historical_volatility(log_returns)
    elif model == 'adjusted':
        return adjusted_volatility(log_returns)
    elif model == 'moving_average':
        return moving_average_volatility(log_returns)
    elif model == 'exponential':
        return exponential_volatility(log_returns)
    else:
        raise ValueError("Modèle de volatilité non reconnu")

# Apply the choosen volatility model
selected_model = 'historical'  # E.g : 'historical', 'adjusted', 'moving_average', 'exponential'

volatility = select_volatility_model(btc_data['Log_Return'], model=selected_model)

adjustment_factor = np.random.uniform(0.3, 1.5, size=len(volatility)) # 0.5 for 50% of the true volatility, 2.0 for 200%

# Apply the adjusted volatility according to the model
adjusted_volatility = volatility * adjustment_factor


# Generate new log yields with selected volatility
seed = 1  # Seed value can be any number for reproducibility
np.random.seed(seed)
random_shocks = np.random.normal(0, 1, len(adjusted_volatility))  # Generate random shocks to lower the correlation
new_log_returns = random_shocks * adjusted_volatility  # Adjusting shocks with the new volatility

# Generate new prices from adjusted log yields
# close_price = btc_data['Close']
close_price = btc_data['Close'].iloc[0]

btc_data['Hybrid_Close'] = close_price * np.exp(np.cumsum(new_log_returns))

btc_data['Hybrid_Close'].iloc[0] = close_price


# Remove Not Available or Not a Number values generated by log yield and volatility calculations
btc_data.dropna(inplace=True)

# Calculate log yields for hybrid values
btc_data['Hybrid_Log_Return'] = np.log(btc_data['Hybrid_Close'] / btc_data['Hybrid_Close'].shift(1))


# Calculate standard deviation of log yields for real and hybrid data
realized_volatility = btc_data['Log_Return'].std() * np.sqrt(360)  # Annualized real price volatility
hybrid_volatility = btc_data['Hybrid_Log_Return'].std() * np.sqrt(360)  # Annualized volatility of hybrid prices


# Calculate correlation between real and hybrid closing prices
closing_price_correlation = btc_data[['Close', 'Hybrid_Close']].corr().iloc[0, 1]


from scipy.stats import wasserstein_distance

wasserstein_dist = wasserstein_distance(btc_data['Log_Return'].dropna(), btc_data['Hybrid_Log_Return'].dropna())
print(f"Wasserstein's distance between real and hybrid log yields: {wasserstein_dist:.2f}")

from scipy.stats import kendalltau

kendall_corr, _ = kendalltau(btc_data['Log_Return'], btc_data['Hybrid_Log_Return'])
print(f"Kendall correlation between real and hybrid log yields: {kendall_corr:.2f}")

from scipy.stats import spearmanr

spearman_corr, _ = spearmanr(btc_data['Log_Return'], btc_data['Hybrid_Log_Return'])
print(f"Spearman correlation between real and hybrid log yields: {spearman_corr:.2f}")

# Recalculation of OHLC prices based on Hybrid_Close
btc_data['Hybrid_Open'] = btc_data['Hybrid_Close'].shift(1)
btc_data['Hybrid_Open'].iloc[0] = btc_data['Hybrid_Close'].iloc[0]  # Fix the first Open value

# Define deviation parameter
deviation = 1000  # For example, you can adjust this value to control the mean deviation

# Small fluctuation for high and low prices
fluctuation_high = np.random.normal(np.random.uniform(0, deviation), 1, size=len(btc_data))
fluctuation_low = np.random.normal(np.random.uniform(0,deviation), 1, size=len(btc_data))

# Calculation of High and Low values
btc_data['Hybrid_High'] = btc_data[['Hybrid_Open', 'Hybrid_Close']].max(axis=1) + fluctuation_high
btc_data['Hybrid_Low'] = btc_data[['Hybrid_Open', 'Hybrid_Close']].min(axis=1) - fluctuation_low

# Ensure High is always higher than Open and Close
btc_data['Hybrid_High'] = btc_data[['Hybrid_Open', 'Hybrid_Close', 'Hybrid_High']].max(axis=1)

# Ensure Low is always lower than Open and Close
btc_data['Hybrid_Low'] = btc_data[['Hybrid_Open', 'Hybrid_Close', 'Hybrid_Low']].min(axis=1)

# Volume adjustment (e.g., random number between 100 and 15000)
btc_data['Hybrid_Volume'] = np.random.uniform(100, 15000, size=len(btc_data))

# Sélectionner uniquement les colonnes OHLCV réelles
btc_data_ohlc = btc_data[['time_period_start', 'Hybrid_Open', 'Hybrid_High', 'Hybrid_Low', 'Hybrid_Close', 'Hybrid_Volume']]

btc_data_ohlc = btc_data_ohlc.rename(columns={'Hybrid_Open': 'price_open', 'Hybrid_High': 'price_high', 'Hybrid_Low': 'price_low', 'Hybrid_Close': 'price_close', 'Hybrid_Volume': 'volume_traded'})

# Export OHLCV data to a CSV file
csv_file_path = f'C:/Users/SolalDanan/enigma-labs-quant-strategy/data/data_simulation/Hybrid_Model/hybrid_model_csv/hybrid_model_ohlcv_btc_usd_{interval}.csv'
btc_data_ohlc.to_csv(csv_file_path, index=True)


# Display results
print(f"Annualized Volatility of Real Prices: {realized_volatility:.2%}")
print(f"Annualized Volatility of Hybrid Prices: {hybrid_volatility:.2%}")
print(f"Correlation between Real and Hybrid Closing Prices: {closing_price_correlation:.2f}")

# Visualization
plt.figure(figsize=(12, 6))
plt.plot(btc_data['Close'], label='Prix Réel')
plt.plot(btc_data['Hybrid_Close'], label='Prix Hybride', linestyle='-')

# Placement of text boxes within the figure space, ensuring they do not overlap with the legend
plt.text(0.05, 0.95, f'Correlation: {closing_price_correlation:.2%}', transform=plt.gca().transAxes, fontsize=10, verticalalignment='top', horizontalalignment='left')
plt.text(0.05, 0.90, f'Real volatility: {realized_volatility:.2%}', transform=plt.gca().transAxes, fontsize=10, verticalalignment='top', horizontalalignment='left')
plt.text(0.05, 0.85, f'Hybrid Volatility: {hybrid_volatility:.2%}', transform=plt.gca().transAxes, fontsize=10, verticalalignment='top', horizontalalignment='left')

# Use 'best' for automatic placement to avoid overlap with your plot elements
plt.legend(loc='upper right')

plt.title('Cours réel vs cours hybride du Bitcoin')
plt.xlabel('Date')
plt.ylabel('Prix')
plt.show()